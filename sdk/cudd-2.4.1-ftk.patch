diff -rup cudd-2.4.1/cudd/cuddAddAbs.c cudd-2.4.1-ftk-patched/cudd/cuddAddAbs.c
--- cudd-2.4.1/cudd/cuddAddAbs.c	2008-03-12 18:19:26.000000000 -0400
+++ cudd-2.4.1-ftk-patched/cudd/cuddAddAbs.c	2008-03-12 18:19:27.000000000 -0400
@@ -230,6 +230,43 @@ Cudd_addOrAbstract(
 } /* end of Cudd_addOrAbstract */
 
 
+/**Function********************************************************************
+
+  Synopsis    [Maximally Abstracts all the variables in cube from f.]
+
+  Description [Abstracts all the variables in cube from f by taking
+  the maximum over all possible values taken by the variable. Returns
+  the abstracted ADD if successful; NULL otherwise. Added by Florent Teichteil-Koenigsbuch (05/04/2006).]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_addExistAbstract Cudd_addUnivAbstract
+  Cudd_addOrAbstract]
+
+******************************************************************************/
+DdNode *
+Cudd_addMaximumAbstract(
+  DdManager * manager,
+  DdNode * f,
+  DdNode * cube)
+{
+    DdNode		*res;
+
+    if (addCheckPositiveCube(manager, cube) == 0) {
+	(void) fprintf(manager->err,"Error:  Can only abstract cubes");
+	return(NULL);
+    }
+
+    do {
+	manager->reordered = 0;
+	res = cuddAddMaximumAbstractRecur(manager, f, cube);
+    } while (manager->reordered == 1);
+
+    return(res);
+
+} /* end of Cudd_addMaximumAbstract */
+
+
 /*---------------------------------------------------------------------------*/
 /* Definition of internal functions                                          */
 /*---------------------------------------------------------------------------*/
@@ -543,6 +580,96 @@ cuddAddOrAbstractRecur(
 } /* end of cuddAddOrAbstractRecur */
 
 
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addMaximumAbstract.]
+
+  Description [Performs the recursive step of Cudd_addMaximumAbstract.
+  Returns the ADD obtained by abstracting the variables of cube from f,
+  if successful; NULL otherwise. Added by Florent Teichteil-Koenigsbuch (05/04/2006).]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+cuddAddMaximumAbstractRecur(
+  DdManager * manager,
+  DdNode * f,
+  DdNode * cube)
+{
+    DdNode	*T, *E, *res, *res1, *res2;
+
+    statLine(manager);
+
+    /* Cube is guaranteed to be a cube at this point. */	
+    if (cuddIsConstant(f) || cuddIsConstant(cube)) {  
+        return(f);
+    }
+
+    /* Abstract a variable that does not appear in f */
+    if (cuddI(manager,f->index) > cuddI(manager,cube->index)) {
+	res = cuddAddMaximumAbstractRecur(manager, f, cuddT(cube));
+    return(res);
+    }
+
+    if ((res = cuddCacheLookup2(manager, Cudd_addMaximumAbstract, f, cube)) != NULL) {
+	return(res);
+    }
+
+    T = cuddT(f);
+    E = cuddE(f);
+
+    /* If the two indices are the same, so are their levels. */
+    if (f->index == cube->index) {
+	res1 = cuddAddMaximumAbstractRecur(manager, T, cuddT(cube));
+	if (res1 == NULL) return(NULL);
+        cuddRef(res1);
+	res2 = cuddAddMaximumAbstractRecur(manager, E, cuddT(cube));
+	if (res2 == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    return(NULL);
+	}
+        cuddRef(res2);
+	res = cuddAddApplyRecur(manager, Cudd_addMaximum, res1, res2);
+	if (res == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    Cudd_RecursiveDeref(manager,res2);
+	    return(NULL);
+	}
+	cuddRef(res);
+	Cudd_RecursiveDeref(manager,res1);
+	Cudd_RecursiveDeref(manager,res2);
+	cuddCacheInsert2(manager, Cudd_addMaximumAbstract, f, cube, res);
+	cuddDeref(res);
+        return(res);
+    } else { /* if (cuddI(manager,f->index) < cuddI(manager,cube->index)) */
+	res1 = cuddAddMaximumAbstractRecur(manager, T, cube);
+	if (res1 == NULL) return(NULL);
+        cuddRef(res1);
+	res2 = cuddAddMaximumAbstractRecur(manager, E, cube);
+	if (res2 == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    return(NULL);
+	}
+        cuddRef(res2);
+	res = (res1 == res2) ? res1 :
+	    cuddUniqueInter(manager, (int) f->index, res1, res2);
+	if (res == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    Cudd_RecursiveDeref(manager,res2);
+	    return(NULL);
+	}
+	cuddDeref(res1);
+	cuddDeref(res2);
+	cuddCacheInsert2(manager, Cudd_addMaximumAbstract, f, cube, res);
+        return(res);
+    }	    
+
+} /* end of cuddAddMaximumAbstractRecur */
+
+
 
 /*---------------------------------------------------------------------------*/
 /* Definition of static functions                                            */
diff -rup cudd-2.4.1/cudd/cudd.h cudd-2.4.1-ftk-patched/cudd/cudd.h
--- cudd-2.4.1/cudd/cudd.h	2008-03-12 18:19:26.000000000 -0400
+++ cudd-2.4.1-ftk-patched/cudd/cudd.h	2008-03-12 18:19:27.000000000 -0400
@@ -750,6 +750,7 @@ extern int Cudd_bddVarIsBound (DdManager
 extern DdNode * Cudd_addExistAbstract (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * Cudd_addUnivAbstract (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * Cudd_addOrAbstract (DdManager *manager, DdNode *f, DdNode *cube);
+extern DdNode * Cudd_addMaximumAbstract (DdManager *manager, DdNode *f, DdNode *cube); /* Added by Florent Teichteil-Koenigsbuch (05/04/2006) */
 extern DdNode * Cudd_addApply (DdManager *dd, DdNode * (*)(DdManager *, DdNode **, DdNode **), DdNode *f, DdNode *g);
 extern DdNode * Cudd_addPlus (DdManager *dd, DdNode **f, DdNode **g);
 extern DdNode * Cudd_addTimes (DdManager *dd, DdNode **f, DdNode **g);
diff -rup cudd-2.4.1/cudd/cuddInt.h cudd-2.4.1-ftk-patched/cudd/cuddInt.h
--- cudd-2.4.1/cudd/cuddInt.h	2008-03-12 18:19:26.000000000 -0400
+++ cudd-2.4.1-ftk-patched/cudd/cuddInt.h	2008-03-12 18:19:27.000000000 -0400
@@ -1018,6 +1018,7 @@ dd->nextSample += 250000;}
 extern DdNode * cuddAddExistAbstractRecur (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * cuddAddUnivAbstractRecur (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * cuddAddOrAbstractRecur (DdManager *manager, DdNode *f, DdNode *cube);
+extern DdNode * cuddAddMaximumAbstractRecur (DdManager *manager, DdNode *f, DdNode *cube); /* Added by Florent Teichteil-Koenigsbuch (05/04/2006) */
 extern DdNode * cuddAddApplyRecur (DdManager *dd, DdNode * (*)(DdManager *, DdNode **, DdNode **), DdNode *f, DdNode *g);
 extern DdNode * cuddAddMonadicApplyRecur (DdManager * dd, DdNode * (*op)(DdManager *, DdNode *), DdNode * f);
 extern DdNode * cuddAddScalarInverseRecur (DdManager *dd, DdNode *f, DdNode *epsilon);
Only in cudd-2.4.1-ftk-patched/cudd: libcudd.a
Only in cudd-2.4.1-ftk-patched/dddmp: libdddmp.a
Only in cudd-2.4.1-ftk-patched/epd: libepd.a
diff -rup cudd-2.4.1/Makefile cudd-2.4.1-ftk-patched/Makefile
--- cudd-2.4.1/Makefile	2008-03-12 18:19:27.000000000 -0400
+++ cudd-2.4.1-ftk-patched/Makefile	2008-03-12 18:19:27.000000000 -0400
@@ -50,7 +50,8 @@ RANLIB	= ranlib
 # These four are typical settings for optimized code with gcc.  The
 # last two also work with icc/ecc.
 #ICFLAGS	= -g -O6 -Wall
-ICFLAGS	= -g -O6
+#ICFLAGS	= -g -O6
+ICFLAGS		= -g -ggdb -O3 -Wall
 #ICFLAGS	= -g -O3 -Wall
 #ICFLAGS	= -g -O3
 
@@ -62,9 +63,9 @@ ICFLAGS	= -g -O6
 #  Linux
 #
 # Gcc 2.8.1 or higher on i686.
-XCFLAGS	= -mcpu=pentiumpro -malign-double -DHAVE_IEEE_754 -DBSD
+#XCFLAGS	= -mcpu=pentiumpro -malign-double -DHAVE_IEEE_754 -DBSD
 # Gcc 3.2.2 or higher on i686.
-#XCFLAGS	= -mcpu=pentium4 -malign-double -DHAVE_IEEE_754 -DBSD
+XCFLAGS	= -mcpu=pentium4 -malign-double -DHAVE_IEEE_754 -DBSD
 # Icc on i686.
 #XCFLAGS	= -ansi -align -ip -DHAVE_IEEE_754 -DBSD
 # Gcc on ia64.
Only in cudd-2.4.1-ftk-patched/mtr: libmtr.a
Only in cudd-2.4.1-ftk-patched/nanotrav: nanotrav
Only in cudd-2.4.1-ftk-patched/st: libst.a
Only in cudd-2.4.1-ftk-patched/util: libutil.a
